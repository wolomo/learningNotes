# 线性表

### 定义

零个或者多个数据元素的有限序列

第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后期

线性表需要同一类型

### 抽象数据类型

线性表

​	|----数据

​	|----操作

​			|----初始化操作

​			|----判断是否为空

​			|----清空线性表

​			|----获取线性表第i个位子的元素

​			|----查找数据为e的元素，返回1表示成功，0表示失败

​			|----在i个位子插入新元素e

​			|----在i个位子删除元素e

​			|----返回线性表长度（元素个数）

其他操作都是由这些基础操作组合实现的

### 顺序存储结构

指用一段地址连续的存储单元，依次存储线性表的数据元素

类似c语言数组

#### 顺序存储结构的属性

+ 存储空间的起始位置
+ 线性表的最大存储容量 MaxSize
+ 线性表的当前长度 length

> 备注：一般数据长度指的是存放的数组的长度，定义一个长度10的数组，只存放了3个数据，则数据长度为3

#### 地址计算方法

地址：存储器中的每个存储单元都有自己的编号，这个编号叫做地址

顺序存储结构中第i的元素的地址=第一元素的地址+i*数据类型的长度

#### 顺序结构的插入和删除

+ 插入算法思路
  + 如果插入的位子不合理，抛出异常
  + 如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量
  + 从最后一个元素遍历的第i个位子，分别向后移动一个位子
  + 将要插入的元素填入位置i处
  + 表长加一
+ 删除操作
  + 如果删除的位置不合理，则抛出异常
  + 取出删除元素
  + 从删除元素的位子开始遍历到最后一个元素位置，分别向前移动一个位子
  + 表长减一

#### 线性表顺序存储结构优缺点

+ 优点 
  + 不需要为表示元素关系增加额外存储空间
  + 可以快速取表中元素
+ 缺点
  + 插入删除需要移动大量元素
  + 线性表长度变化较大时，很难确定存储空间的容量
  + 造成内存的碎片

### 链式存储结构

​	为了表示每个数据元素i与之后的i+1的逻辑关系，对数据元素i来说，除了存储本身信息以外，还要存储一个指示其后继的信息

链式存储结构 = 数据域 + 指针域

链表的第一个结点的存储位置叫头指针

链表的最后一个结点指针为null

#### 单链表

n个结点构成一个链表，每个节点只包含一个指针域，指针域指向下一个元素的地址，叫做单链表

##### 单链表的读取

获得第i个数据的算法思路

+ 声明一个结点p指向链表的第一个节点，初始化j从1开始
+ 当j<i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
+ 若到链表末尾p为空，则说明i不存在
+ 否则查找成功，返回p的数据

##### 单链表的插入

假设存储元素e的节点为s，将s插入到p和p->next中间

1. s->next = p->next
2. p->next =s

单链表第i个数据插入节点的算法思路

+ 声明一结点p指向链表的第一个节点，初始化j从1开始
+ 当j<i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
+ 若到链表末尾p为空，则说明i不存在
+ 否则查找成功，在系统中生成节点s
+ 将数据元素e赋值给s->data
+ 单链表的标准插入语句s->next = p->next    p->next =s
+ 返回成功

##### 单链表的删除

q = p->next    p ->next = q->next

或者 p->next = p->next->next

单链表第i个数据删除节点的算法思路

+ 声明一结点p指向链表的第一个结点，初始化j从1开始
+ 当j<i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
+ 若到链表末尾p为空，则说明i不存在
+ 否则查找成功，将要删除的节点p-next赋值给q
+ 单链表标准删除语句 p->next = q->next
+ 将q界面的数据赋值给e，作为返回
+ 释放q节点（free（q））

##### 单链表整表创建

算法思路（头插法）

+ 声明头节点和计数器变量i
+ 初始化一空链表L
+ 让L的头节点的指针指向NULL，建立一个带头结点的单链表
+ 循环：
  + 生成一个新节点赋值给p
  + 生成一数字赋值给p->data
  + 将p插入头结点与前一新结点之间

算法思路（尾插法）

+ 声明头节点和计数器变量i
+ 初始化一空链表L
+ 让L的头节点的指针指向NULL，建立一个带头结点的单链表
+ 创建一个指针r指向尾部节点
+ 循环
  + 生成新结点，将值赋给p
  + 生成一数字赋值给p->data
  + 将尾表终端结点的指针指向新结点
  + 将当前的新结点定义为尾结点 r = p
+ 当r->next为空的时候，表示当前链表结束

##### 单链表整表删除

算法思路：

+ 声明结点p和q
+ 将第一个结点赋值给p
+ 循环
  + 将下一结点赋值给q
  + 释放p
  + 将q赋值给p

+ 当头节点指针为空，则删除成功

#### 静态链表

数组模拟链表

#### 单循环链表

将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表。

当p->next = head的时候，表示循环结束。

我们在循环链表中  可以有尾指针rear

开始结点就是 rear ->next ->next

#### 双向链表

双向链表是在单链表的每个节点中，在设置一个指向前驱结点的指针域，所以双向链表有两个指针域，一个指向后继next，一个指向直接前驱prior。

##### 插入操作

将结点s插入到p的后面

s->prior = p

s->next  = p+1

p->next ->prior = s

p->next=s



##### 删除操作

删除p结点

p->prior->next = p->next

p->next->prior = p-prior

free(p)

