# 串

## 定义

又零个或者多个字符组成的有序序列，又叫做字符串

串的字符数目叫做串的长度

零个字符的串称为空串

“序列”：说明相邻字符之间具有前驱和后继的关系

**一些概念**

+ 空格串：只包含空格的串
+ 子串和主串：串中任意个数的连续字符组成的子序列称为该串的子串。

## 串的比较

串的比较是通过串的字符之间的编码来进行的

【ASCII  UNICODE UTF-8】

### 定义串大小的比较

字符串1 s = “a1a2...an”

字符串1 t = “b1b2...bm”

满足以下条件之一则s<t

+ n<m 且 ai = bi    (happ 和happy)
+ 存在 k <= min(m,n) ，ai = bi，ak<bk (hapay和happy)

## 串的抽象数据类型

串（string）

​	|----数据(仅有一个字符组成，去油前驱后继关系)

​	|----操作

​			|----生成一个值等于字符串常量chars的串T

​			|----串S存在，由串S复制得到串T

​			|----串S存在，清空

​			|----判断串是否为空，返回true ，false

​			|----返回串的元素个数，即串的长度

​			|----比较两个串的大小

​			|----返回两个串连接而成的新串

​			|----截取从i开始 长度为l的子串

​			|----比较两个串是否出现相同子串，是则返回位置

​			|----替换字符串S中所有和T相同的子串为V

​			|----在S中的i个位子插入T

​			|----在S中的i个位子删除长度为l的字符，返回新的S

​			

## 串的存储结构

### 顺序存储结构

+ 用一组地址连续的存储单元来存储串中的字符序列

+ 存在一个预定义的最大串长度，

+ 可以将实际的串长度保存在数组的0下标位置，

+ 也可以在串值后面加一个不计入串长度的结束标记字符“\0”

+ 容易溢出

### 链式存储结构

+ 一个结点可以存放一个字符很浪费，所有一个结点可以存放多个字符，若最后一个结点未满，可以用“#”占满
+ 没有顺序存储灵活，性能也没有顺序存储好

## 字符串匹配算法

### 1. 朴素匹配算法

对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配；对主串做大循环，每个字符开头做T长度的小循环，直到匹配成功或者全部遍历完成为止。

```c
//从S中找T，返回位子pos
int Index(String S,String T ,int pos){
 	//i用于主串S中当期位置下标,若pos不为1,则从pos开始
    int i = pos;
    //j用于子串T当前位置下标值
    int j = 1;
    //假设字符长度存在S[0]和T[0]中
    //若i小于S长度且j小于T长度
    while(i<S[0]&& j<=T[0]){
        //若相等,继续
        if(S[i] = T[i]){
            ++i;
            ++j
        }else{
            //i跳到之后的位子
            i = i-j+2
            j=1
        }
    }
    if(j>T[0]){
        return i-T[0]
    }else{
        return 0
    }  
}
```

###  2.KMP模式匹配算法

避免重复遍历

step1 找到子串T的next数组

stop2 匹配算法

