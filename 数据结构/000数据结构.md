# 数据结构和算法

## 数据结构

### 逻辑结构

1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

### 存储结构

1. 顺序存储结构
2. 链式存储结构

## 算法

采用技巧和方式来解决问题

### 五个特征

输入 输出 有穷性 确定性 可信性

### 算法的四个层次

1. 算法程序没有语法错误
2. 算法程序对合法输入能够产生满足要求的输出
3. 算法程序对非法输入能够产生满足规格的说明
4. 算法程序对于故意刁难的测试输入都有满足要求的输出结果

## 时间复杂度和空间复杂度

### 度量方法

事后统计算法

事前估计方法

+ 算法采用的策略，方案
+ 编译产生的代码质量
+ 问题的输入规模 

### 时间复杂度

T(n) = O(f(n))

+ 使用1代表常数
+ 运行次数函数中，只去最高阶
+ 最高阶用常数代替 就乘以n

指数阶 ---- 循环是导致时间复杂度的主要原因

对数阶 ---- 

### 空间复杂度

先存好OTK

## 一.线性表（List）

### 1.定义

排队一样，具有线一样的性质

+ 有零个或者多个数据元素组成的有限序列

+ 第一个元素没有前驱 最后一个元素没有后继 其他元素有且只有一个前驱和后继

### 2.基本操作

+ 初始化

+ 删除
+ 返回个数
+ 插入元素
+ 删除某位置的元素

### 3.线性表的顺序存储结构

类似数组

#### 属性

+ 存储空间的起始位子
+ 最大存储容量
+ 当前长度

#### 地址计算方法

+ 第i个元素的位子 = 第一个元素的位子 + （i-1）*长度

#### 获得元素操作 O（1）

Elem[i-1]

#### 插入操作 O（n）

插入位子不合理，抛异常

插入后线性表长度大于数组长度，抛出异常或者动态增加数组容量

从最后一个元素遍历到i位子，分别将他们都向后移动一个位子

将元素插入到位子i

线性表长度+1

#### 删除操作 O（n）

删除的位子不在数组长度内，抛出异常

找到位子i的元素，取出来

将i位子到最后一个元素往前移动一个位子

线性表长度-1

#### 总结

优点：适合取值和查找

缺点：不适合插入删除操作

### 4.线性表的链式存储结构

每个元素多用一个位子来存放指向下一个元素的位置的指针

数据域+指针域 = 结点

#### 单链表

​	指向第一个节点的指针叫头指针，最后一个节点指针为空

​	无论链表是否为空，头指针都不能为空

   + **读取第i个数据 O(n)**

     1. 声明一个节点p指向链表的第一个节点，初始化j从1开始
     2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j+1
     3. 若到末尾p为空，则不存在i，否则查找成功，找到节点p数据

+  **i位子插入数据 O(n)**

  ​	s->next =  p->next      p->next = s

  1. 声明一个节点p指向链表的第一个节点，初始化j从1开始
  2. 当j<1时，遍历链表，让p的指针向后移动，不断到下一个结点，j++
  3. 若到末尾p为空，则不存在i，若查找成功，生成一个空节点s，将数据复制给s，
  4. 让s->next指向p->next,再让p->next指向s

+ **删除i位置数据 O(n)**

  1. 声明一个节点p指向链表的第一个节点，初始化j从1开始

  2. 当j<1时，遍历链表，让p的指针向后移动，不断到下一个结点，j++
  3. 若到末尾p为空，则不存在i，若查找成功，
  4. 将p->next指向p->next->next

+ **单链表创建**

  + 【头插法】从第一个位子依次执行插入数据操作
  + 【尾插法】遍历长度 r（int r= 0；r<数据长度，r++），从r的地方执行插入p数据 ，然后将r重新指向当前插入的元素（r++）（r=p）

+ 单链表销毁

  + 将头节点指向p
  + 判断p是否为空，非空就将p-next指向q，然后释放p，再将q等于p，再循环
  + 最后将头节点设为空

  ##### 总结

  插入删除大量数据时，第一个是O（n），后面的都是O(1)

  可以使用零碎的空间 

  适合插入删除，不适合查找

#### 静态链表

一定的长度

游标 -- 数据 -- 下标

第一个和最后一个元素的data不存放数据

前一个游标等于下一个数据的下标

最后一个数据的游标等于第一个有数据的下标

链表头游标为最后一个数据的游标，下标为0

####单链表题目

找到链表中间节点

解：快慢节点，快节点+2，慢节点+1，当快节点遍历到尾部时，慢节点到中间位子

#### 单向循环链表

单链表只能从头节点开始  ==  诸多限制

单循环链表  == 单链表中终端节点的指针端由空指针指向头节点

 判断为空 条件由head->next ==null 为head->next==head

#### 双向循环链表

双向循环链表 数据结构： 前驱 -- 数据 -- 后继

前驱指针指向上一个节点的数据，后继指针指向下一个节点的数据。

空的双向循环链表 前驱指向数据，后继指向数据

head->next = head &&head->prior= head





#### 

