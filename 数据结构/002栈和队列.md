# 栈和队列

## 定义

栈：限定仅在表尾插入和删除操作的线性表

队列：只允许在一端进行插入操作，在另一端进行删除操作的线性表

## 栈

### 定义

我们把允许插入和删除的一称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又被称为后进先出（Last In First Out）（LIFO）的线性表

+ 栈的插入操作：进栈、入栈、压栈
+ 栈的删除操作：出栈

### 抽象数据类型

栈（stack）

​	|----数据

​	|----操作

​			|----初始化操作

​			|----若栈存在，则销毁

​			|----清空栈

​			|----若栈为空。返回true，否则false

​			|----若栈存在且非空，用e返回栈顶元素

​			|----若栈存在，插入新元素e称为栈顶元素

​			|----删除栈顶元素，并返回改元素值e

​			|----返回栈长度（元素个数）

### 栈的顺序存储结构

以下标为0的一端作为栈底，

设定top变量为栈顶元素在数组中的位置

设定存储栈的长度为StackSize，

#### 进栈操作

+ 判断是否栈满，是则抛出异常
+ 栈顶指针增加1
+ 将新的元素赋值给栈顶空间

#### 出栈操作

+ 判断是否为空栈。是则抛出异常
+ 将栈顶元素赋值给e
+ 栈顶指针减去1
+ 返回e

#### 两栈共享空间

数组有两个端点，两个栈有两个栈底。

让一个栈的栈底为数组的始端，一个栈底为数组末端

这样就是两个栈栈底对着

当两个栈顶相遇的时候，数组就满了



### 栈的链式存储结构

栈顶放在单链表的头部

不存在栈满的存在，除非内存炸了

#### 进栈操作 push

将e元素插入栈S的栈顶

+ 生成空结点s
+ 将e的值赋给s->data
+ 将原来的栈顶元素赋值给新结点的直接后继
  + s->next = S->head
+ 将新结点s赋值给栈顶指针
  + S->head = s
+ S->count ++

#### 出栈操作 pop

将栈S的栈顶元素出栈，并且获得值e

+ 判断栈是否为空，是则报错
+ 将栈顶数据赋值给e
  + *e = S->head->data
+ 将栈顶元素赋值给p
+ 将栈顶元素指针向下移动一位
  + S->head= S->head->next
+ 释放掉p
+ S->count --

### 栈的应用-递归

#### 定义

一个直接调用自己或者通过一系列的调用语言间接调用自己的的函数，称为递归函数

#### 条件

每个递归定义必须至少有一个条件，满足是递归不再进行，不再引用自身而是返回值退出

递归过程中，退回的顺序就是它前行顺序的逆序；在退回的过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。

这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，很符合使用栈这样的数据结构。

### 栈的应用-四则运算表达式求值

9+(3-1)*3+10/2

#### 后缀表达式计算结果

规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果

后缀表达式：9 3 1  - 3 * + 10 2 / +

#### 中缀表达式转后缀表达式

中缀表达式 = 标准四则运算表达式

规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断与栈顶符号的优先级，是右括号或者优先级低于栈顶符号，则栈顶元素依次出栈并输出，并与当前符号进栈，一直到最终输出后缀表达式为止。





## 队列

### 定义

队列是一种先进先出的线性表。允许插入的一端是队尾，允许删除的一端称为队头。

### 队列的抽象数据类型

队列（Queue）

​	|----数据（线性表）

​	|----操作

​			|----初始化操作，建立空队列Q

​			|----若队列Q存在，则销毁

​			|----清空队列Q

​			|----若队列Q为空。返回true，否则false

​			|----若队列Q存在且非空，用e返回队头元素

​			|----若队列Q存在，插入新元素e到队列中并成为队尾元素

​			|----删除队头元素，并返回该元素值e

​			|----返回队列长度（元素个数）

### 循环队列

头尾相接的顺序存储结构称为循环队列

队列引用两个指针，front指针指向队头元素，rear指向队尾元素的下一个位子。

入队的时候，rear++

出队的时候，front++

当rear==front时，队列为空

#### 循环队列的顺序存储结构

+ 数据 data
+ 头指针 front
+ 尾指针 rear

#### 循环队列的初始化代码

+ Q->front =0
+ Q->rear=0

#### 循环队列求队列长度的代码

+ (Q.rear - Q.front + MAXSIZE)%MAXSIZE

#### 循环队列入队代码

+ 如果队列满了 返回异常
+ 将元素e赋值给队尾
  + Q->data[Q->rear] =e
+ rear指针向后移动一位置，若到了数组最后则跳转到数组头部

#### 循环队列的出队列操作代码如下

+ 如果队列空了 返回异常
+ 将队头元素赋值给e
+ front指针向后移动一个位置，若到最后则转到数组头部
  + Q->front = (Q->front + 1)%MAXSIZE

### 队列的链式存储结构及实现

其实就是线性表的单链表，只能尾进头出，简称链队列

空队列时，front 和 rear 都指向头结点。

#### 链队列的结构

+ 数据 data
+ 队头指针 front
+ 队尾指针 rear

#### 链队列入队操作

链表Q尾部插入结点 ,内容为e

+ 创建一个结点s
+ 将数据放到s的数据
  + s->data = e
+ s结点的下一结点为空
  + s->next = null
+ 将s赋值给原队尾结点的后继
  + Q->rear ->next = s
+ 把当前的s设置为队尾结点，rear指向s
  + Q->rear = s

#### 链队列出队操作

链表头部结点出队

+ 判断链队列是否为空，是则返回异常
+ 将队头元素赋值给p
  + p = Q->front->next
+ 将队头元素的值赋给e
  + *e = p->data
+ 将原队头结点后继赋值给头结点后继
  + Q->front->next = Q->front->next->next (Q->front->next = p->next)
+ 若队头就是队尾，则删除后将rear指向头结点
  + Q-rear = Q ->front
+ free(p)   或者（Q->front->next）

