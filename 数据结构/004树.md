# 树

## 定义

树是n个结点的有限集合,n=0时为空树,在任意一颗非空树种:

1. 有且只有一个特定的称为根(Root)的结点.
2. 当n>1时,其余结点可分为m(m>0)个互不相交的有限集T1,T2,...Tn,其中每个集合本身又是一棵树,并且称为根的子树
3. n>0时根节点是唯一的,不可能存在多个根节点
4. m>0时,子树的个数没有限制,但是一定互不相交

### 结点分类

结点拥有的子树数称为结点的度(Degree).

度为0的结点称为叶结点(leaf)或者终端结点.

度不为0的称分支结点或者非终端结点

整个树的度是树内各节点的度的最大值

### 结点间的关系

结点的子树的根 称为该结点的孩子,

相应的,该结点称为孩子的双亲

同一个双亲的孩子之间互称兄弟.

结点的祖先是从根到该结点所经分支的所有结点

以某结点为根的子树中的任一结点都成为该结点的子孙

双亲在同一层的结点互为堂兄弟

### 树的其他相关概念

结点的层次是从根结点开始算的

结点的最大层次称为树的深度或者高度

如果将树的结点子树从左到右是有次序,不能互换的,则称该树为有序树,否则为无序树

森林是m颗互不相交的树的集合

## 树的抽象数据类型

树（tree）

​	|----数据

​		|----一个根结点和若干子树,树中结点具有相同的数据类型和层次关系.

​	|----操作

​			|----构造空树

​			|----若树存在，则销毁

​			|----给出树的定义来构造树

​			|----若树T存在,则将树T清空

​			|----若T为空树,返回true,否则返回false

​			|---返回T的深度

​			|----返回T的根结点

​			|----返回T中结点的值

​			|----给T中结点的赋值

​			|----判断是否为非根结点,是则返回双亲,否则返回空

​			|----判断是否是非叶结点,是则返回左孩子,否则返回空			

​			|----将树c插入树T中p结点的第i颗子树

​			|----删除树T中p结点的第i颗子树

## 树的存储结构

简单的顺序存储和链式存储不能实现树的存储结构



>存储结构是一个非常灵活的过程,一个存储结构设计的是否合理,取决于基于该存储结构的运算是否适合,是否方便,时间复杂度好不好等.

### 1.双亲表示法

#### 方案一

在没个结点中,附设一个指示器指示其双亲结点到链表的位置

| 下标 | 数据 | 双亲指针 |
| ---- | ---- | -------- |
| i    | data | parent   |

根结点没有双亲,指针域设定为-1

很容易通过parent指针找到双亲结点

但是如果想要知道结点的孩子是什么,需要遍历一遍

#### **==>改进**

数据结构增加结点最左边孩子的域

| 下标 | 数据 | 双亲指针 | 长子指针   |
| ---- | ---- | -------- | ---------- |
| i    | data | parent   | firstchild |

无长子的话为-1

能够解决找结点孩子的问题,能够找到firstchild,就能找到所有的兄弟节点了.

#### **==>改进**

关注个兄弟之间的关系

| 下标 | 数据 | 双亲指针 | 右兄弟指针 |
| ---- | ---- | -------- | ---------- |
| i    | data | parent   | rightsib   |

右兄弟不存在,则为-1

能够找到结点的兄弟,从而兄弟关系更加清晰

### 2.孩子表示法

每个结点有多个指针,其中每个指针指向一颗子树的根结点,

#### 方案一

|      | 指针1  | 指针2  | ...  | 指针n  | 树的深度 |
| ---- | ------ | ------ | ---- | ------ | -------- |
| data | child1 | child1 |      | childn | childd   |

data是数据, child1~childn 都是指向孩子结点的指针,

childd是记录了树的度,同时,存储结构的长也为childd

当树中额各个结点的度相差很大,就很浪费空间



#### 方案2

| 数据 | 指针1  | 指针2  | ...  | 指针n  | 树的深度 |
| ---- | ------ | ------ | ---- | ------ | -------- |
| data | child1 | child1 |      | childn | childd   |

data是数据, child1~childn 都是指向孩子结点的指针,

childd是记录了每一个结点的孩子结点的个数,存储结构的长度也为childd

客服了空间上的浪费,但是计算时间上就需要很多时间

#### 孩子表示法

把结点的孩子结点排列起来,以单链表作为存储结构,则n个结点有n个孩子链表.如果是叶子结点则此单链表为空,然后,n个头指针又组成一个线性表, 采用顺序存储结构,存放进一个一维数组中.

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-孩子表示法.png)

优点:遍历整棵树很方便;查找某个结点的某个孩子,或者某个结点的兄弟,只需要查找这个结点的单链表就可以了.

缺点:不知道双亲

#### 双亲孩子表示法

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-双亲孩子表示法.png)

### 3.孩子兄弟表示法

任意一个结点,右兄弟和第一个孩子都是唯一的.

结构可以为:

| 数据 | 长子       | 右兄弟   |
| ---- | ---------- | -------- |
| data | firstchild | rightsib |

任意结点可以通过firstchild找到结点的长子,再通过长子结点找到二弟.

可以将复杂树变成了二叉树





## 二叉树

### 定义

二叉树是n个结点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的,分别称为根结点的左子树和右子树的二叉树组成,

### 特点

1. 每个节点最多有两颗子树,所以二叉树不存在度大于2的结点
2. 左子树和右子树是有顺序的,不能颠倒
3. 即使某结点只有一颗子树,也要区分左子树还是右子树

### 二叉树5种形态

1. 空二叉树
2. 只有一个根结点
3. 根结点只有左子树
4. 根结点只有右子树
5. 根结点既有左子树,又有右子树

#### 特殊二叉树

+ 斜树:所有的结点只有左子树的二叉树叫做左斜树;所有的结点只有右子树的二叉树叫做右斜树.
+ 满二叉树:二叉树中所有分支结点都存在左子树和右子树,并且所有叶子都在同一层上.
+ 完全二叉树: 对一颗具有n个结点的二叉树按层序编号,如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位子完全相同,则称为完全二叉树.



### 二叉树性质

+ 在二叉树的第i层最多有2^(i-1)个结点
+ 深度为k的二叉树至多有2^k -1个结点
+ 对任何一颗二叉树,如果其终端结点树为n0,度为2的结点数为n2,则n0=n2+1
+ 具有n个结点的完全二叉树深度为log2 n+1
+ 如果对一颗有n个结点的完全二叉树的结点按层编号,对任一结点i有:
  + 如果 i=1,则结点i是二叉树的根,无双亲;如果i>1,则其双亲是结点[i/2]
  + 如果2i>n,则结点i无左孩子;否则其左孩子是结点2i
  + 如果2i+1>n,则结点无右孩子;否则其右孩子是结点2i+1 

### 二叉树的顺序存储结构

一维数组存储二叉树的结点,并且结点的存储位置,也就是数组的下标要能体现结点之间的逻辑关系.

**一般完全二叉树可以这样定义**

对于一般的二叉树,尽管层序编号不能反映逻辑关系,但是可以按照完全二叉树编号,把不存在的结点设置为"^".

一颗深度为k的二叉树,需要分配2^k -1 个存储单元.

### 二叉树的链式存储结构

二叉树每个结点最多有两个孩子,所以为它设计一个数据域和两个指针域,称为二叉链表

| 左孩子指针 | 数据 | 右孩子指针 |
| ---------- | ---- | ---------- |
| lchild     | data | rchild     |

如果有需要,可以再增加一个指向双亲的指针域,就可以称为三叉链表了.



### 遍历二叉树

是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次有仅被访问一次

#### 1.前序遍历

若二叉树为空,则空操作返回,否则先访问根结点.然后前序遍历左子树,再前序遍历右子树.

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-前序遍历.png)

> 算法

```c
void PreOrderTraverse(BiTree T){
    if(T ==null) return
    printf("%c",T->data)
    PreOrderTraverse(T->lchild)
    PreOrderTraverse(T->rchild)
}

/*
	**递归调用PreOrderTraverse方法**
	重复调用PreOrderTraverse(T->lchild)方法,先将左结点遍历完,遍历到G的时候返回,于是调用PreOrderTraverse(T->rchild)方法,遍历右结点.遍历到H返回,
	调用PreOrderTraverse(T->rchild)遍历到C,再递归调用PreOrderTraverse(T->lchild)遍历到e...
	总结:先遍历左边,左边遍历完返回遍历上一结点的右边,

*/

```



#### 2.中序遍历

若树为空,则空操作返回,否则从根结点开始,中序遍历根结点的子树,然后是访问根结点,最后中序遍历右子树.

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-中序遍历.png)

> 算法

```c
void InOrderTraverse(BiTree T){
    if(T ==null) return
    InOrderTraverse(T->lchild)
	printf("%c",T->data)
    InOrderTraverse(T->rchild)
}

/*
	首先先把左边全部遍历了,然后输出G
	然后没有左孩子和右孩子,就返回到d
	d输出右孩子,...
	
*/

```



#### 3.后序遍历

若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点,

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-后序遍历.png)

> 算法

```c
void PostOrderTraverse(BiTree T){
    if(T ==null) return
    PostOrderTraverse(T->lchild)
    PostOrderTraverse(T->rchild)
    printf("%c",T->data)
}

/*
	首先先把左边全部遍历了,然后输出G
	然后没有左孩子和右孩子,就返回到d
	d输出右孩子,...
	
*/

```

#### 4.层序遍历

若树为空,则空操作返回,否则从树的第一层,也就是根结点开始,从上到下逐层遍历,在同一层,按从左到右的顺序对结点逐个访问

### 二叉树的建立

先将二叉树进行扩展,确定每个结点都有左右孩子,

二叉树的每个结点的空指针引出一个虚节点,用"#"代替.



比如 前序遍历序列 为 字符串AB#D##C##

```c
void CreateBiTree(Bitree  *T){
    TElemType ch;
    scanf("%c",&ch)
    if(ch == "#"){
        *T = NULL;
    }else{
        *T = (Bitree)malloc(sizeof(BiTNode));
        if(!*T)
            exit(OVERFLOW);
        (*T)->data = ch;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
           
}
```

###  线索二叉树

#### 定义

上述二叉树建立的时候,还是有很多空指针的,可以利用起来

**二叉树中指向前驱和后继的指针称为线索**

**加上线索的二叉链表称为线索链表,相应的二叉树就称为线索二叉树**

我们对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化.

| 左指针 | 左指针标识符 | 数据 | 右指针标识符 | 右指针 |
| ------ | ------------ | ---- | ------------ | ------ |
| lchild | ltag         | data | rtag         | rchild |

+ ltag为0时lchild指向该结点的左孩子,为1时指向该结点的前驱
+ rtag为0时rchild指向该结点的右孩子,为1时指向该结点的后继

#### 结构

```c
typedef struct BiThrNode
{
	TElemType	data;
	struct BiThrNode *lchild	*rchild;
	PointerTag   lTag;
	PointerTag   RTag;
}
```



### 树/森林与二叉树的转换

#### 树转换为二叉树

1. 加线:在所有兄弟结点之间加一条连线
2. 去线:对数的每个结点,只保留它与第一个孩子结点的连线,删除它与其他孩子结点之间的连线
3. 层次调整:以树的根结点为轴心,将整棵树顺时针旋转一定角度,使之结构分明,注意第一个孩子是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-树转二叉树.png)

#### 二叉树转换为树

1. 加线:若某结点的左孩子结点存在,则将这个左孩子的n个右孩子结点都作为此结点的孩子,将该结点与这些右孩子结点用线连起来.
2. 去线:删除原二叉树中所有结点与其右孩子结点的连线
3. 层次调整:使结构更加分明

### 赫夫曼树

#### 一些定义

+ 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称作路径长度
+ 树的路径长度就是从 树根到每一个节点的路径长度之和
+ 带权路径长度是指,指从该结点到树根之间的路径长度与结点上权的乘积
+ 带权路径长度WPL最小的二叉树称作赫夫曼树

#### 怎样构建赫夫曼树

1. 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列.例:A5,E10,B15,D30,C40
2. 取头两个最小权值的结点作为一个新节点N1的两个子节点,相对较小的是左孩子,例:A为N1左孩子,E为N1右孩子.新节点权值和为5+10 = 15
3. 将N1替换为A与E,插入有序序列中,保持从小到大的排列,即:N115,B15,D30,C40
4. 重复2/3步骤

>官方版本
>
>1. 根据给定的n个权值{w1,w2,w3....}构成n颗二叉树的集合F={T1,T2,T3...},其中每颗二叉树Ti中只有一个带权为Wi根结点,其左右子树均为空.
>2. 在F中选取两颗根结点的权值最小的树作为左右子树构造一颗新的二叉树,且置新的二叉树的根结点的权值为左右子树上根结点权值之和
>3. 在F中删除这两棵树,同时将新得到的二叉树加入F中
>4. 重复2和3,直到F只含一棵树为止

#### 赫夫曼编码

+ 材料:一串字符,

+ 处理:⑴字符的种类,⑵字符出现的个数(权值)

+ 构造:

  + 按照赫夫曼树的构造的方式,生成赫夫曼树,
  + 左子树分支为0,右子树为1
  + 每个字符的编码为根结点到叶子节点的权值

  