# 树

## 定义

树是n个结点的有限集合,n=0时为空树,在任意一颗非空树种:

1. 有且只有一个特定的称为根(Root)的结点.
2. 当n>1时,其余结点可分为m(m>0)个互不相交的有限集T1,T2,...Tn,其中每个集合本身又是一棵树,并且称为根的子树
3. n>0时根节点是唯一的,不可能存在多个根节点
4. m>0时,子树的个数没有限制,但是一定互不相交

### 结点分类

结点拥有的子树数称为结点的度(Degree).

度为0的结点称为叶结点(leaf)或者终端结点.

度不为0的称分支结点或者非终端结点

整个树的度是树内各节点的度的最大值

### 结点间的关系

结点的子树的根 称为该结点的孩子,

相应的,该结点称为孩子的双亲

同一个双亲的孩子之间互称兄弟.

结点的祖先是从根到该结点所经分支的所有结点

以某结点为根的子树中的任一结点都成为该结点的子孙

双亲在同一层的结点互为堂兄弟

### 树的其他相关概念

结点的层次是从根结点开始算的

结点的最大层次称为树的深度或者高度

如果将树的结点子树从左到右是有次序,不能互换的,则称该树为有序树,否则为无序树

森林是m颗互不相交的树的集合

## 树的抽象数据类型

树（tree）

​	|----数据

​		|----一个根结点和若干子树,树中结点具有相同的数据类型和层次关系.

​	|----操作

​			|----构造空树

​			|----若树存在，则销毁

​			|----给出树的定义来构造树

​			|----若树T存在,则将树T清空

​			|----若T为空树,返回true,否则返回false

​			|---返回T的深度

​			|----返回T的根结点

​			|----返回T中结点的值

​			|----给T中结点的赋值

​			|----判断是否为非根结点,是则返回双亲,否则返回空

​			|----判断是否是非叶结点,是则返回左孩子,否则返回空			

​			|----将树c插入树T中p结点的第i颗子树

​			|----删除树T中p结点的第i颗子树

## 树的存储结构

简单的顺序存储和链式存储不能实现树的存储结构



>存储结构是一个非常灵活的过程,一个存储结构设计的是否合理,取决于基于该存储结构的运算是否适合,是否方便,时间复杂度好不好等.

### 1.双亲表示法

#### 方案一

在没个结点中,附设一个指示器指示其双亲结点到链表的位置

| 下标 | 数据 | 双亲指针 |
| ---- | ---- | -------- |
| i    | data | parent   |

根结点没有双亲,指针域设定为-1

很容易通过parent指针找到双亲结点

但是如果想要知道结点的孩子是什么,需要遍历一遍

#### **==>改进**

数据结构增加结点最左边孩子的域

| 下标 | 数据 | 双亲指针 | 长子指针   |
| ---- | ---- | -------- | ---------- |
| i    | data | parent   | firstchild |

无长子的话为-1

能够解决找结点孩子的问题,能够找到firstchild,就能找到所有的兄弟节点了.

#### **==>改进**

关注个兄弟之间的关系

| 下标 | 数据 | 双亲指针 | 右兄弟指针 |
| ---- | ---- | -------- | ---------- |
| i    | data | parent   | rightsib   |

右兄弟不存在,则为-1

能够找到结点的兄弟,从而兄弟关系更加清晰

### 2.孩子表示法

每个结点有多个指针,其中每个指针指向一颗子树的根结点,

#### 方案一

|      | 指针1  | 指针2  | ...  | 指针n  | 树的深度 |
| ---- | ------ | ------ | ---- | ------ | -------- |
| data | child1 | child1 |      | childn | childd   |

data是数据, child1~childn 都是指向孩子结点的指针,

childd是记录了树的度,同时,存储结构的长也为childd

当树中额各个结点的度相差很大,就很浪费空间



#### 方案2

| 数据 | 指针1  | 指针2  | ...  | 指针n  | 树的深度 |
| ---- | ------ | ------ | ---- | ------ | -------- |
| data | child1 | child1 |      | childn | childd   |

data是数据, child1~childn 都是指向孩子结点的指针,

childd是记录了每一个结点的孩子结点的个数,存储结构的长度也为childd

客服了空间上的浪费,但是计算时间上就需要很多时间

#### 孩子表示法

把结点的孩子结点排列起来,以单链表作为存储结构,则n个结点有n个孩子链表.如果是叶子结点则此单链表为空,然后,n个头指针又组成一个线性表, 采用顺序存储结构,存放进一个一维数组中.

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-孩子表示法.png)

优点:遍历整棵树很方便;查找某个结点的某个孩子,或者某个结点的兄弟,只需要查找这个结点的单链表就可以了.

缺点:不知道双亲

#### 双亲孩子表示法

![](C:\Users\wolomo\Desktop\学习笔记\MD学习笔记\learningNotes\数据结构\树-双亲孩子表示法.png)

### 3.孩子兄弟表示法

任意一个结点,右兄弟和第一个孩子都是唯一的.

结构可以为:

| 数据 | 长子       | 右兄弟   |
| ---- | ---------- | -------- |
| data | firstchild | rightsib |

任意结点可以通过firstchild找到结点的长子,再通过长子结点找到二弟.

可以将复杂树变成了二叉树





## 二叉树

### 定义

二叉树是n个结点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的,分别称为根结点的左子树和右子树的二叉树组成,

### 特点

1. 每个节点最多有两颗子树,所以二叉树不存在度大于2的结点
2. 左子树和右子树是有顺序的,不能颠倒
3. 即使某结点只有一颗子树,也要区分左子树还是右子树

### 二叉树5种形态

1. 空二叉树
2. 只有一个根结点
3. 根结点只有左子树
4. 根结点只有右子树
5. 根结点既有左子树,又有右子树

#### 特殊二叉树

+ 斜树:所有的结点只有左子树的二叉树叫做左斜树;所有的结点只有右子树的二叉树叫做右斜树.
+ 满二叉树:二叉树中所有分支结点都存在左子树和右子树,并且所有叶子都在同一层上.
+ 完全二叉树: 对一颗具有n个结点的二叉树按层序编号,如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位子完全相同,则称为完全二叉树.



### 二叉树性质

